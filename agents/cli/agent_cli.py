# agents/cli/agent_cli.py

import argparse
import asyncio
import json
import logging
import os
import sys
from datetime import datetime
from typing import Dict, List, Any, Optional
import uuid  # Import uuid

# Local imports (adjust as needed)
try:
    from ..base_agent import BaseAgent
    from ..db.postgres import PostgresClient
    from ..llm.vertex_gemini_provider import VertexGeminiProvider
    from ..memory.vector_memory import EnhancedVectorMemory  # Use EnhancedVectorMemory
    from ..communication.protocol import (
        CommunicationProtocol,
        AgentMessage,
        MessageType,
    )
    from ..factory import AgentFactory, AGENT_TYPE_MAP  # Import AGENT_TYPE_MAP
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(__file__), "..", ".."))
    from agents.base_agent import BaseAgent
    from agents.db.postgres import PostgresClient
    from agents.llm.vertex_gemini_provider import VertexGeminiProvider
    from agents.memory.vector_memory import EnhancedVectorMemory
    from agents.communication.protocol import (
        CommunicationProtocol,
        AgentMessage,
        MessageType,
    )
    from agents.factory import AgentFactory, AGENT_TYPE_MAP  # Import AGENT_TYPE_MAP

# Set up logging for the CLI
log_file = "agent_cli.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),  # Log to console
        logging.FileHandler(log_file),  # Log to file
    ],
)

logger = logging.getLogger("agent.cli")


class AgentCLI:
    """Command-line interface for testing agent interactions."""

    def __init__(self):
        self.db_client: Optional[PostgresClient] = None
        self.llm_provider: Optional[VertexGeminiProvider] = None
        self.vector_memory: Optional[EnhancedVectorMemory] = None
        self.comm_protocol: CommunicationProtocol = CommunicationProtocol()
        self.agent_factory: Optional[AgentFactory] = (
            None  # Add factory instance variable
        )
        # self.agents: Dict[str, BaseAgent] = {} # No longer needed to track agents in memory
        self._initialized = False

    async def initialize(self) -> None:
        """Initialize the CLI and required services."""
        if self._initialized:
            return
        logger.info("Initializing CLI services...")
        try:
            # Initialize database client
            self.db_client = PostgresClient()
            await self.db_client.initialize()

            # Initialize LLM provider
            self.llm_provider = VertexGeminiProvider()

            # Initialize vector memory
            self.vector_memory = EnhancedVectorMemory(self.db_client)
            await self.vector_memory.initialize()

            # Initialize Agent Factory with shared dependencies
            self.agent_factory = AgentFactory(
                llm_provider=self.llm_provider,
                db_client=self.db_client,
                vector_memory=self.vector_memory,
                comm_protocol=self.comm_protocol,
            )

            self._initialized = True
            logger.info("CLI services initialized successfully.")
        except Exception as e:
            logger.error(f"CLI Initialization failed: {e}", exc_info=True)
            sys.exit(1)

    async def _ensure_initialized(self):
        if not self._initialized:
            await self.initialize()
        if not self._initialized:
            raise RuntimeError("CLI Services could not be initialized.")

    async def create_agent(
        self, agent_type: str, agent_name: str, capabilities_json: Optional[str] = None
    ) -> Optional[str]:
        """Create a new agent instance, register it in DB, and return its ID."""
        await self._ensure_initialized()

        if not self.agent_factory:
            logger.error("Agent Factory is not initialized.")
            return None

        capabilities = {}
        if capabilities_json:
            try:
                capabilities = json.loads(capabilities_json)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON format for capabilities: {e}")
                return None

        try:
            # 1. Create agent instance using the factory
            # The factory now handles passing dependencies
            agent_instance = self.agent_factory.create_agent(
                agent_type=agent_type,
                agent_name=agent_name,
                capabilities=capabilities,
                # agent_id is generated by default in BaseAgent constructor
            )

            # 2. Explicitly register the agent in the database
            # (Overwrites/confirms registration potentially started by BaseAgent.__init__)
            query_insert = """
            INSERT INTO agents (agent_id, agent_type, agent_name, capabilities, active)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (agent_id) DO UPDATE SET
                agent_type = EXCLUDED.agent_type,
                agent_name = EXCLUDED.agent_name,
                capabilities = EXCLUDED.capabilities,
                active = EXCLUDED.active
            """
            await self.db_client.execute(
                query_insert,
                agent_instance.agent_id,
                agent_instance.agent_type,
                agent_instance.agent_name,
                json.dumps(agent_instance.capabilities),
                True,  # Default to active
            )

            # Correct indentation (aligned with try):
            logger.info(
                f"Agent {agent_instance.agent_id} ({agent_instance.agent_name}) created and registered/updated in DB."
            )
            print(f"Agent Created: ID = {agent_instance.agent_id}")
            return agent_instance.agent_id

        except ValueError as e:
            # Handle unknown agent type from factory
            logger.error(f"Agent creation failed: {e}")
            print(f"Error: {e}")
            return None
        except Exception as e:
            # Handle other potential errors (DB connection, etc.)
            logger.error(
                f"Unexpected error creating agent {agent_name} of type {agent_type}: {e}",
                exc_info=True,
            )
            print(f"Error: Could not create agent. Check logs.")
            return None

    async def list_agents(self) -> List[Dict[str, Any]]:
        """List all agents registered in the database."""
        await self._ensure_initialized()
        if not self.db_client:
            logger.error("Database client not available.")
            return []

        query = """
        SELECT agent_id, agent_type, agent_name, created_at, capabilities, active
        FROM agents
        ORDER BY created_at DESC
        """
        try:
            results = await self.db_client.fetch_all(query)
            agents_data = []
            for row in results:
                agents_data.append(
                    {
                        "agent_id": str(row["agent_id"]),
                        "agent_type": row["agent_type"],
                        "agent_name": row["agent_name"],
                        "created_at": row["created_at"].isoformat(),
                        "capabilities": (
                            json.loads(row["capabilities"])
                            if row["capabilities"]
                            else {}
                        ),
                        "active": row["active"],
                    }
                )
            return agents_data
        except Exception as e:
            logger.error(f"Failed to list agents from database: {e}", exc_info=True)
            return []

    # --- Task 3: Fix send_message ---
    async def send_message(
        self,
        sender_id: str,
        receiver_id: str,
        content: str,
        message_type_str: str = "INFORM",
        conv_id: Optional[str] = None,
        task_id: Optional[str] = None,
        metadata_json: Optional[str] = None,
    ) -> Optional[str]:
        """Send a message from one agent to another by logging it directly to DB."""
        await self._ensure_initialized()

        # Validate sender_id exists in the database
        sender_exists = await self._check_agent_exists(sender_id)
        if not sender_exists:
            logger.error(f"Sender agent {sender_id} not found in database.")
            print(f"Error: Sender agent ID {sender_id} does not exist.")
            return None

        # Validate receiver_id exists in the database
        receiver_exists = await self._check_agent_exists(receiver_id)
        if not receiver_exists:
            logger.error(f"Receiver agent {receiver_id} not found in database.")
            print(f"Error: Receiver agent ID {receiver_id} does not exist.")
            return None

        # Validate message type
        try:
            message_type = MessageType(message_type_str.upper())
        except ValueError:
            valid_types = [t.value for t in MessageType]
            logger.error(f"Invalid message type: {message_type_str}")
            print(
                f"Error: Invalid message type '{message_type_str}'. Valid: {valid_types}"
            )
            return None

        # Parse metadata JSON
        metadata = {}
        if metadata_json:
            try:
                metadata = json.loads(metadata_json)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON format for metadata: {e}")
                print(f"Error: Invalid JSON for metadata: {e}")
                return None

        # Create the message object using the protocol
        # Generate a new UUID for the message
        message_id = str(uuid.uuid4())
        created_at = datetime.now()

        # Store message directly in the database
        query_insert_msg = """
        INSERT INTO agent_messages (
            message_id, timestamp, sender_id, receiver_id,
            message_type, content, related_task_id,
            metadata
            -- parent_message_id - currently not handled by CLI
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING message_id
        """

        try:
            await self.db_client.execute(
                query_insert_msg,
                message_id,
                created_at,
                sender_id,
                receiver_id,
                message_type.value,
                content,
                task_id,
                json.dumps(metadata or {}),
            )
            logger.info(
                f"Message {message_id} logged to DB: {sender_id} -> {receiver_id}"
            )

            # Store vector embedding for the message (if components available)
            await self._store_message_embedding(
                message_id,
                content,
                sender_id,
                receiver_id,
                message_type.value,
                task_id,
                metadata,
            )

            print(f"Message Sent (Logged to DB): ID = {message_id}")
            return message_id

        except Exception as e:
            logger.error(
                f"Failed to log message to DB from {sender_id} to {receiver_id}: {e}",
                exc_info=True,
            )
            print("Error: Failed to send/log message. Check logs.")
            return None

    async def _check_agent_exists(self, agent_id: str) -> bool:
        """Check if an agent ID exists in the database."""
        query = "SELECT 1 FROM agents WHERE agent_id = $1"
        result = await self.db_client.fetch_one(query, agent_id)
        return result is not None

    async def _store_message_embedding(
        self,
        message_id: str,
        content: str,
        sender_id: str,
        receiver_id: str,
        msg_type: str,
        task_id: Optional[str],
        metadata: Dict[str, Any],
    ):
        """Generate and store vector embedding for a message."""
        if self.vector_memory and self.llm_provider:
            try:
                embedding = await self.llm_provider.generate_embeddings(content)
                if embedding:
                    await self.vector_memory.store_entity(
                        entity_type="AgentMessage",
                        entity_id=message_id,
                        content=content,
                        embedding=embedding,
                        metadata={
                            "sender": sender_id,
                            "receiver": receiver_id,
                            "type": msg_type,
                            "task_id": task_id,
                            **(metadata or {}),
                        },
                        tags=["communication", msg_type.lower()],
                    )
                    logger.debug(f"Stored embedding for message {message_id}")
                else:
                    logger.warning(
                        f"Failed to generate embedding for message {message_id}"
                    )
            except Exception as e:
                logger.error(
                    f"Failed to store embedding for message {message_id}: {e}",
                    exc_info=True,
                )
        else:
            logger.debug(
                "Skipping message embedding: Vector Memory or LLM Provider not available."
            )

    async def get_agent_messages(
        self, agent_id: str, limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get recent messages received by the specified agent."""
        await self._ensure_initialized()
        if not self.db_client:
            logger.error("Database client not available.")
            return []

        # Fetch directly from DB instead of using agent instance
        query = """
        SELECT
            message_id, timestamp, sender_id, receiver_id,
            message_type, content, related_task_id, metadata
        FROM agent_messages
        WHERE receiver_id = $1
        ORDER BY timestamp DESC
        LIMIT $2
        """
        try:
            results = await self.db_client.fetch_all(query, agent_id, limit)
            messages = []
            for row in results:
                messages.append(
                    {
                        "message_id": str(row["message_id"]),
                        "timestamp": row["timestamp"].isoformat(),
                        "sender_id": str(row["sender_id"]),
                        "receiver_id": str(row["receiver_id"]),
                        "message_type": row["message_type"],
                        "content": row["content"],
                        "related_task_id": (
                            str(row["related_task_id"])
                            if row["related_task_id"]
                            else None
                        ),
                        "metadata": (
                            json.loads(row["metadata"]) if row["metadata"] else {}
                        ),
                    }
                )
            return messages
        except Exception as e:
            logger.error(
                f"Failed to fetch messages for agent {agent_id}: {e}", exc_info=True
            )
            return []

    async def search_knowledge(
        self, query: str, limit: int = 5
    ) -> List[Dict[str, Any]]:
        """Search for knowledge (currently messages) related to the query using vector search."""
        await self._ensure_initialized()
        if not self.vector_memory or not self.llm_provider:
            logger.error("Required components (LLM, Memory) not available for search.")
            return []

        try:
            query_embedding = await self.llm_provider.generate_embeddings(query)
            if not query_embedding:
                logger.error("Failed to generate query embedding.")
                return []

            # Directly use vector_memory search
            similar_results = await self.vector_memory.search_similar(
                query_embedding=query_embedding,
                entity_types=["AgentMessage"],  # Example: search only messages
                limit=limit,
                # Add threshold if desired
            )

            # Format results (similar_results format depends on vector_memory implementation)
            # Assuming it returns a list of dicts with 'metadata' and 'similarity' keys
            formatted_results = []
            for res in similar_results:
                # Add similarity score if available
                res_data = res.get("metadata", {})
                res_data["similarity_score"] = res.get("similarity")
                res_data["entity_id"] = res.get("entity_id")  # Include the message ID
                formatted_results.append(res_data)

            return formatted_results

        except Exception as e:
            logger.error(f"Knowledge search failed: {e}", exc_info=True)
            return []

    async def get_agent_activities(
        self, agent_id: str, activity_type: Optional[str] = None, limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get recent activities logged for the specified agent."""
        await self._ensure_initialized()
        if not self.db_client:
            logger.error("Database client not initialized.")
            return []

        conditions = ["agent_id = $1"]
        params: List[Any] = [agent_id]
        param_idx = 2

        if activity_type:
            conditions.append(f"activity_type ILIKE ${param_idx}")
            params.append(f"%{activity_type}%")
            param_idx += 1

        query = f"""
        SELECT
            activity_id, timestamp, activity_type,
            description, thought_process, input_data, output_data,
            decisions_made, execution_time_ms, related_task_id, related_files
        FROM agent_activities
        WHERE {" AND ".join(conditions)}
        ORDER BY timestamp DESC
        LIMIT ${param_idx}
        """
        params.append(limit)

        try:
            results = await self.db_client.fetch_all(query, *params)
            activities = []
            for row in results:
                activities.append(
                    {
                        "activity_id": str(row["activity_id"]),
                        "timestamp": row["timestamp"].isoformat(),
                        "agent_id": agent_id,  # Add agent_id for clarity
                        "activity_type": row["activity_type"],
                        "description": row["description"],
                        "thought_process": row["thought_process"],
                        "input_data": (
                            json.loads(row["input_data"]) if row["input_data"] else {}
                        ),
                        "output_data": (
                            json.loads(row["output_data"]) if row["output_data"] else {}
                        ),
                        "decisions_made": (
                            json.loads(row["decisions_made"])
                            if row["decisions_made"]
                            else {}
                        ),
                        "execution_time_ms": row["execution_time_ms"],
                        "related_task_id": (
                            str(row["related_task_id"])
                            if row["related_task_id"]
                            else None
                        ),
                        "related_files": row["related_files"] or [],
                    }
                )
            return activities
        except Exception as e:
            logger.error(
                f"Failed to get activities for agent {agent_id}: {e}", exc_info=True
            )
            return []

    async def close(self) -> None:
        """Close database connections and other resources."""
        if self.db_client:
            await self.db_client.close()
        self._initialized = False
        logger.info("CLI resources closed.")


async def run_cli():
    """Parses arguments and runs the appropriate CLI command."""
    parser = argparse.ArgumentParser(description="Autonomous Agent System CLI Tool")
    subparsers = parser.add_subparsers(
        dest="command", help="Available commands", required=True
    )

    # --- Agent Commands ---
    parser_agent = subparsers.add_parser("agent", help="Manage agents")
    agent_subparsers = parser_agent.add_subparsers(
        dest="agent_command", help="Agent actions", required=True
    )

    # agent create
    parser_agent_create = agent_subparsers.add_parser(
        "create", help="Create a new agent and register in DB"
    )
    parser_agent_create.add_argument(
        "--type",
        type=str,
        required=True,  # Make type required
        help=f"Type of agent. Known: {list(AGENT_TYPE_MAP.keys())}",
    )
    parser_agent_create.add_argument(
        "--name", type=str, required=True, help="Name for the new agent"
    )
    parser_agent_create.add_argument(
        "--capabilities",
        type=str,
        help="JSON string of agent capabilities, e.g., '{\"can_code\": true}'",
    )

    # agent list
    agent_subparsers.add_parser("list", help="List registered agents from DB")

    # agent activities
    parser_agent_activities = agent_subparsers.add_parser(
        "activities", help="Show agent activities from DB"
    )
    parser_agent_activities.add_argument(
        "--id", type=str, required=True, help="Agent ID"
    )
    parser_agent_activities.add_argument(
        "--type", type=str, help="Filter by activity type (e.g., CodeGeneration)"
    )
    parser_agent_activities.add_argument(
        "--limit", type=int, default=10, help="Maximum activities to show (default: 10)"
    )

    # --- Message Commands ---
    parser_message = subparsers.add_parser("message", help="Manage messages")
    message_subparsers = parser_message.add_subparsers(
        dest="message_command", help="Message actions", required=True
    )

    # message send
    parser_message_send = message_subparsers.add_parser(
        "send", help="Send a message (logs directly to DB)"
    )
    parser_message_send.add_argument(
        "--sender", type=str, required=True, help="Sender Agent ID (must exist in DB)"
    )
    parser_message_send.add_argument(
        "--receiver",
        type=str,
        required=True,
        help="Receiver Agent ID (must exist in DB)",
    )
    parser_message_send.add_argument(
        "--content", type=str, required=True, help="Message content"
    )
    parser_message_send.add_argument(
        "--type",
        type=str,
        default="INFORM",
        help=f"Message type (default: INFORM). Valid: {[t.value for t in MessageType]}",
    )
    parser_message_send.add_argument(
        "--conv_id", type=str, help="Optional conversation UUID"
    )
    parser_message_send.add_argument(
        "--task_id", type=str, help="Optional related task UUID"
    )
    parser_message_send.add_argument(
        "--metadata",
        type=str,
        help='Optional JSON string for metadata, e.g., \'{"priority": "high"}\'',
    )

    # message show
    parser_message_show = message_subparsers.add_parser(
        "show", help="Show messages received by an agent from DB"
    )
    parser_message_show.add_argument(
        "--id", type=str, required=True, help="Agent ID whose messages to show"
    )
    parser_message_show.add_argument(
        "--limit", type=int, default=10, help="Maximum messages to show (default: 10)"
    )

    # --- Knowledge Commands ---
    parser_knowledge = subparsers.add_parser(
        "knowledge", help="Interact with knowledge base"
    )
    knowledge_subparsers = parser_knowledge.add_subparsers(
        dest="knowledge_command", help="Knowledge actions", required=True
    )

    # knowledge search
    parser_knowledge_search = knowledge_subparsers.add_parser(
        "search", help="Search knowledge base (messages) via vector similarity"
    )
    parser_knowledge_search.add_argument(
        "--query", type=str, required=True, help="Search query string"
    )
    parser_knowledge_search.add_argument(
        "--limit", type=int, default=5, help="Maximum results (default: 5)"
    )

    args = parser.parse_args()
    cli = AgentCLI()

    try:
        if args.command == "agent":
            if args.agent_command == "create":
                result = await cli.create_agent(
                    agent_type=args.type,
                    agent_name=args.name,
                    capabilities_json=args.capabilities,
                )
            elif args.agent_command == "list":
                result = await cli.list_agents()
                print(json.dumps(result, indent=2))
            elif args.agent_command == "activities":
                result = await cli.get_agent_activities(
                    agent_id=args.id, activity_type=args.type, limit=args.limit
                )
                print(json.dumps(result, indent=2))

        elif args.command == "message":
            if args.message_command == "send":
                result = await cli.send_message(
                    sender_id=args.sender,
                    receiver_id=args.receiver,
                    content=args.content,
                    message_type_str=args.type,
                    conv_id=args.conv_id,
                    task_id=args.task_id,
                    metadata_json=args.metadata,
                )
            elif args.message_command == "show":
                result = await cli.get_agent_messages(
                    agent_id=args.id, limit=args.limit
                )
                print(json.dumps(result, indent=2))

        elif args.command == "knowledge":
            if args.knowledge_command == "search":
                result = await cli.search_knowledge(query=args.query, limit=args.limit)
                print(json.dumps(result, indent=2))

    except Exception as e:
        logger.error(f"CLI command failed: {e}", exc_info=True)
        print(f"Error: An unexpected error occurred. Check logs in {log_file}")
    finally:
        await cli.close()


def main():
    # Add check for Python version if needed
    if sys.version_info < (3, 8):
        sys.exit("Python 3.8 or higher is required.")

    # Setup asyncio loop
    try:
        asyncio.run(run_cli())
    except KeyboardInterrupt:
        logger.info("CLI terminated by user.")
        print("\nCLI terminated.")


if __name__ == "__main__":
    main()
